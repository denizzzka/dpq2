       |///
       |module dpq2.conv.to_d_types;
       |
       |@safe:
       |
       |import dpq2.value;
       |import dpq2.oids: OidType, isNativeInteger, isNativeFloat;
       |import dpq2.connection: Connection;
       |import dpq2.query: QueryParams;
       |import dpq2.result: msg_NOT_BINARY;
       |import dpq2.conv.from_d_types;
       |import dpq2.conv.numeric: rawValueToNumeric;
       |import dpq2.conv.time: binaryValueAs, TimeStamp, TimeStampUTC;
       |import dpq2.conv.geometric: binaryValueAs, Line;
       |
       |import vibe.data.json: Json, parseJsonString;
       |import vibe.data.bson: Bson;
       |import std.traits;
       |import std.uuid;
       |import std.datetime;
       |import std.traits: isScalarType;
       |import std.typecons : Nullable;
       |import std.bitmanip: bigEndianToNative;
       |import std.conv: to;
       |
       |// Supported PostgreSQL binary types
       |alias PGboolean =       bool; /// boolean
       |alias PGsmallint =      short; /// smallint
       |alias PGinteger =       int; /// integer
       |alias PGbigint =        long; /// bigint
       |alias PGreal =          float; /// real
       |alias PGdouble_precision = double; /// double precision
       |alias PGtext =          string; /// text
       |alias PGnumeric =       string; /// numeric represented as string
       |alias PGbytea =         immutable(ubyte)[]; /// bytea
       |alias PGuuid =          UUID; /// UUID
       |alias PGdate =          Date; /// Date (no time of day)
       |alias PGtime_without_time_zone = TimeOfDay; /// Time of day (no date)
       |alias PGtimestamp = TimeStamp; /// Both date and time without time zone
       |alias PGtimestamptz = TimeStampUTC; /// Both date and time stored in UTC time zone
       |alias PGjson =          Json; /// json or jsonb
       |alias PGline =          Line; /// Line (geometric type)
       |
       |private alias VF = ValueFormat;
       |private alias AE = ValueConvException;
       |private alias ET = ConvExceptionType;
       |
       |/// Returns cell value as native string based type from text or binary formatted field
       |T as(T)(in Value v) pure @trusted
       |if(is(T : string))
       |{
    101|    if(v.format == VF.BINARY)
       |    {
     97|        if(!(
       |            v.oidType == OidType.Text ||
     27|            v.oidType == OidType.FixedString ||
     26|            v.oidType == OidType.VariableString ||
     25|            v.oidType == OidType.Numeric ||
      2|            v.oidType == OidType.Json ||
      1|            v.oidType == OidType.Jsonb
       |        ))
      1|            throwTypeComplaint(v.oidType, "Text, FixedString, VariableString, Numeric, Json or Jsonb", __FILE__, __LINE__);
       |
     96|        if(v.oidType == OidType.Numeric)
     23|            return rawValueToNumeric(v.data).to!T;
       |    }
       |
     77|    return valueAsString(v).to!T;
       |}
       |
       |/// Returns value as D type value from binary formatted field
       |T as(T)(in Value v)
       |if(!is(T : string) && !is(T == Bson))
       |{
     63|    if(!(v.format == VF.BINARY))
0000000|        throw new AE(ET.NOT_BINARY,
       |            msg_NOT_BINARY, __FILE__, __LINE__);
       |
       |    static if (is(T == Nullable!R, R))
       |    {
      6|        if (v.isNull) return T.init;
      4|        return T(binaryValueAs!(TemplateArgsOf!T[0])(v));
       |    }
     58|    else return binaryValueAs!T(v);
       |}
       |
       |package:
       |
       |/*
       | * Something was broken in DMD64 D Compiler v2.079.0-rc.1 so I made this "tunnel"
       | * TODO: remove it and replace by direct binaryValueAs calls
       | */
       |auto tunnelForBinaryValueAsCalls(T)(in Value v)
       |{
     21|    return binaryValueAs!T(v);
       |}
       |
       |string valueAsString(in Value v) pure
       |{
     96|    if (v.isNull) return null;
     92|    return (cast(const(char[])) v.data).to!string;
       |}
       |
       |/// Returns value as bytes from binary formatted field
       |T binaryValueAs(T)(in Value v)
       |if(is(T : const ubyte[]))
       |{
      2|    if(!(v.oidType == OidType.ByteArray))
0000000|        throwTypeComplaint(v.oidType, "immutable ubyte[]", __FILE__, __LINE__);
       |
      2|    return v.data;
       |}
       |
       |/// Returns cell value as native integer or decimal values
       |///
       |/// Postgres type "numeric" is oversized and not supported by now
       |T binaryValueAs(T)(in Value v)
       |if( isNumeric!(T) )
       |{
       |    static if(isIntegral!(T))
     30|        if(!isNativeInteger(v.oidType))
0000000|            throwTypeComplaint(v.oidType, "integral types", __FILE__, __LINE__);
       |
       |    static if(isFloatingPoint!(T))
      4|        if(!isNativeFloat(v.oidType))
0000000|            throwTypeComplaint(v.oidType, "floating point types", __FILE__, __LINE__);
       |
     34|    if(!(v.data.length == T.sizeof))
0000000|        throw new AE(ET.SIZE_MISMATCH,
       |            to!string(v.oidType)~" length ("~to!string(v.data.length)~") isn't equal to native D type "~
       |                to!string(typeid(T))~" size ("~to!string(T.sizeof)~")",
       |            __FILE__, __LINE__);
       |
     31|    ubyte[T.sizeof] s = v.data[0..T.sizeof];
     31|    return bigEndianToNative!(T)(s);
       |}
       |
       |/// Returns UUID as native UUID value
       |UUID binaryValueAs(T)(in Value v)
       |if( is( T == UUID ) )
       |{
      2|    if(!(v.oidType == OidType.UUID))
0000000|        throwTypeComplaint(v.oidType, "UUID", __FILE__, __LINE__);
       |
      2|    if(!(v.data.length == 16))
0000000|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres UUID size", __FILE__, __LINE__);
       |
      2|    UUID r;
      2|    r.data = v.data;
      2|    return r;
       |}
       |
       |/// Returns boolean as native bool value
       |bool binaryValueAs(T : bool)(in Value v)
       |if (!is(T == Nullable!R, R))
       |{
      9|    if(!(v.oidType == OidType.Bool))
0000000|        throwTypeComplaint(v.oidType, "bool", __FILE__, __LINE__);
       |
      9|    if(!(v.data.length == 1))
0000000|        throw new AE(ET.SIZE_MISMATCH,
       |            "Value length isn't equal to Postgres boolean size", __FILE__, __LINE__);
       |
      9|    return v.data[0] != 0;
       |}
       |
       |/// Returns Vibe.d's Json
       |Json binaryValueAs(T)(in Value v) @trusted
       |if( is( T == Json ) )
       |{
       |    import dpq2.conv.jsonb: jsonbValueToJson;
       |
      8|    Json res;
       |
      8|    switch(v.oidType)
       |    {
      6|        case OidType.Json:
       |            // represent value as text and parse it into Json
      6|            string t = v.valueAsString;
      6|            res = parseJsonString(t);
      6|            break;
       |
      2|        case OidType.Jsonb:
      2|            res = v.jsonbValueToJson;
      2|            break;
       |
0000000|        default:
0000000|            throwTypeComplaint(v.oidType, "json or jsonb", __FILE__, __LINE__);
       |    }
       |
      8|    return res;
       |}
src/dpq2/conv/to_d_types.d is 79% covered
